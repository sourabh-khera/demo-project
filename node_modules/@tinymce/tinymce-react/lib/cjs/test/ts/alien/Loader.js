"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var agar_1 = require("@ephox/agar");
var katamari_1 = require("@ephox/katamari");
var React = require("react");
var ReactDOM = require("react-dom");
var TinyMCE_1 = require("src/main/ts/TinyMCE");
var Editor_1 = require("../../../main/ts/components/Editor");
require("tinymce/tinymce");
var setTinymceBaseUrl = function (baseUrl) {
    var tinymce = TinyMCE_1.getTinymce();
    var prefix = document.location.protocol + '//' + document.location.host;
    tinymce.baseURL = baseUrl.indexOf('://') === -1 ? prefix + baseUrl : baseUrl;
    tinymce.baseURI = new tinymce.util.URI(tinymce.baseURL);
};
var getTestEditor = function (onLoaded) {
    return function (props) {
        var originalInit = props.init || {};
        var originalSetup = originalInit.setup || katamari_1.Fun.noop;
        var ref = React.createRef();
        var init = __assign({}, originalInit, { setup: function (editor) {
                originalSetup(editor);
                editor.on('SkinLoaded', function () {
                    setTimeout(function () {
                        onLoaded(editor, ref);
                    }, 0);
                });
            } });
        setTinymceBaseUrl(init.base_url || "/project/node_modules/tinymce");
        return React.createElement(Editor_1.Editor, __assign({ ref: ref }, props, { init: init }));
    };
};
var cSetup = function (createElement) {
    return agar_1.Chain.async(function (_, next, die) {
        var root = document.createElement('div');
        document.body.appendChild(root);
        var onEditorLoaded = function (editor, ref) {
            katamari_1.Option.from(ref.current)
                .map(ReactDOM.findDOMNode)
                .filter(function (val) { return val instanceof Element; })
                .fold(function () { return die('Could not find DOMNode'); }, function (DOMNode) {
                next({
                    ref: ref,
                    root: root,
                    editor: editor,
                    DOMNode: DOMNode
                });
            });
        };
        var testEditor = getTestEditor(onEditorLoaded);
        var editorElement = createElement(testEditor);
        ReactDOM.render(editorElement, root);
    });
};
exports.cSetup = cSetup;
var cRemove = agar_1.Chain.op(function (res) {
    ReactDOM.unmountComponentAtNode(res.root);
});
exports.cRemove = cRemove;
var cNamedChainDirect = function (name) { return agar_1.NamedChain.direct(agar_1.NamedChain.inputName(), agar_1.Chain.mapper(function (res) { return res[name]; }), name); };
exports.cNamedChainDirect = cNamedChainDirect;
var cDOMNode = function (chain) {
    return agar_1.NamedChain.asChain([
        cNamedChainDirect('DOMNode'),
        agar_1.NamedChain.read('DOMNode', chain),
        agar_1.NamedChain.outputInput
    ]);
};
exports.cDOMNode = cDOMNode;
var cEditor = function (chain) {
    return agar_1.NamedChain.asChain([
        cNamedChainDirect('editor'),
        agar_1.NamedChain.read('editor', chain),
        agar_1.NamedChain.outputInput
    ]);
};
exports.cEditor = cEditor;
