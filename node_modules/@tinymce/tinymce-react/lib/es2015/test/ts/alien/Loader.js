var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { Chain, NamedChain } from '@ephox/agar';
import { Fun, Option } from '@ephox/katamari';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { getTinymce } from 'src/main/ts/TinyMCE';
import { Editor } from '../../../main/ts/components/Editor';
import 'tinymce/tinymce';
var setTinymceBaseUrl = function (baseUrl) {
    var tinymce = getTinymce();
    var prefix = document.location.protocol + '//' + document.location.host;
    tinymce.baseURL = baseUrl.indexOf('://') === -1 ? prefix + baseUrl : baseUrl;
    tinymce.baseURI = new tinymce.util.URI(tinymce.baseURL);
};
var getTestEditor = function (onLoaded) {
    return function (props) {
        var originalInit = props.init || {};
        var originalSetup = originalInit.setup || Fun.noop;
        var ref = React.createRef();
        var init = __assign({}, originalInit, { setup: function (editor) {
                originalSetup(editor);
                editor.on('SkinLoaded', function () {
                    setTimeout(function () {
                        onLoaded(editor, ref);
                    }, 0);
                });
            } });
        setTinymceBaseUrl(init.base_url || "/project/node_modules/tinymce");
        return React.createElement(Editor, __assign({ ref: ref }, props, { init: init }));
    };
};
var cSetup = function (createElement) {
    return Chain.async(function (_, next, die) {
        var root = document.createElement('div');
        document.body.appendChild(root);
        var onEditorLoaded = function (editor, ref) {
            Option.from(ref.current)
                .map(ReactDOM.findDOMNode)
                .filter(function (val) { return val instanceof Element; })
                .fold(function () { return die('Could not find DOMNode'); }, function (DOMNode) {
                next({
                    ref: ref,
                    root: root,
                    editor: editor,
                    DOMNode: DOMNode
                });
            });
        };
        var testEditor = getTestEditor(onEditorLoaded);
        var editorElement = createElement(testEditor);
        ReactDOM.render(editorElement, root);
    });
};
var cRemove = Chain.op(function (res) {
    ReactDOM.unmountComponentAtNode(res.root);
});
var cNamedChainDirect = function (name) { return NamedChain.direct(NamedChain.inputName(), Chain.mapper(function (res) { return res[name]; }), name); };
var cDOMNode = function (chain) {
    return NamedChain.asChain([
        cNamedChainDirect('DOMNode'),
        NamedChain.read('DOMNode', chain),
        NamedChain.outputInput
    ]);
};
var cEditor = function (chain) {
    return NamedChain.asChain([
        cNamedChainDirect('editor'),
        NamedChain.read('editor', chain),
        NamedChain.outputInput
    ]);
};
export { cSetup, cRemove, cNamedChainDirect, cDOMNode, cEditor };
